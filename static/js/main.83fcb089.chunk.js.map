{"version":3,"sources":["domain/algorithms.tsx","components/settings/algorithmExplanation.tsx","components/settings/algorithmSetting.tsx","domain/colors.tsx","components/sidebar.tsx","data-structure/priorityQueue.tsx","components/message.tsx","components/home.tsx","app.tsx","reportWebVitals.ts","index.tsx"],"names":["Algorithms","AlgorithmExplanation","props","algorithm","contentText","onClose","open","React","scroll","handleClose","descriptionElementRef","descriptionElement","current","focus","Dialog","aria-labelledby","aria-describedby","DialogTitle","id","DialogContent","dividers","DialogContentText","ref","tabIndex","component","DialogActions","Button","onClick","useStyles","makeStyles","theme","createStyles","formControl","margin","spacing","minWidth","marginLeft","formControlAddEdge","dialogTitle","textAlign","selectEmpty","marginTop","addNodeIcon","marginBottom","color","fontSize","cursor","addEdgeIcon","clearExecutionGraphBtn","removeGraphBtn","executeAlgorithmExecuteBtn","sliderRoot","width","SimpleDialog","classes","nodes","useState","chosenFromNode","setFromNode","chosenToNode","setToNode","chosenEdgeWeight","setEdgeWeight","e","target","innerText","fromNode","toNode","weight","nodeOptions","i","push","MenuItem","value","className","FormControl","InputLabel","Select","labelId","onChange","event","TextField","label","type","Colors","AlgorithmSetting","chosenAlgorithm","setAlgorithm","chosenStartingNode","setStartingNode","chosenTargetNode","setTargetNode","isDirected","setDirection","chosenSpeed","setSpeed","openDialog","setOpenDialog","openDialogAlgorithmExp","setOpenDialogAlgorithmExp","handleExecuteAlgorithm","algorithms","BFS","DFS","DIJKSTRA","BELLMAN_FORD","KRUSKAL","algorithmOptions","length","FormControlLabel","control","Switch","checked","changeGraphDirection","name","disabled","ListItem","ListItemIcon","Tooltip","title","aria-label","addNode","toString","indexOf","Typography","gutterBottom","Slider","defaultValue","getAriaValueText","speed","step","marks","min","max","newValue","Number","valueLabelDisplay","variant","clearExecution","clearGraph","edge","addEdge","style","executionOption","startingNode","targetNode","executeVisualization","drawerWidth","root","display","appBar","transition","transitions","create","easing","sharp","duration","leavingScreen","appBarShift","easeOut","enteringScreen","menuButton","marginRight","hide","drawer","flexShrink","drawerPaper","drawerHeader","alignItems","padding","mixins","toolbar","justifyContent","content","flexGrow","contentShift","SideBar","useTheme","setOpen","CssBaseline","AppBar","position","clsx","Toolbar","IconButton","noWrap","Drawer","anchor","paper","direction","Divider","PriorityQueue","collection","this","element","isEmpty","added","weightToNode","splice","shift","Message","show","Alert","severity","message","Component","Home","componentDidMount","a","getElementByIdAsync","startGraph","Promise","resolve","getElement","document","getElementById","requestAnimationFrame","bind","handleGraphDirection","executeGraphVisualization","updateFinishAlgorithmState","state","graphStruct","executed","start","finish","setState","greuler","update","oldGraphState","nextNodeId","graph","u","v","source","directed","displayWeight","setTimeout","instance","adjacencyList","makeUnweightedGraph","dfs","then","bfs","makeWeightedGraph","dijkstra","edgeList","makeEdgeListGraph","bellmanFord","kruskal","visited","delay","edges","edgeIdx","selector","getEdge","attr","RED","console","log","queue","currentNode","startNode","times","forEach","node","Infinity","backtrace","pq","enqueue","shortestStep","dequeue","neighbor","GREEN","time","idx","pathIdx","lastStep","unshift","dist","nodesLength","j","edgeId","PURPLE","Math","floor","sortedEdges","sort","b","mst","components","parent","rank","edgeCount","find","sourceRoot","targetRoot","union","GREY","elementX","elementY","rootX","rootY","removeNodesByFn","n","left","top","transform","height","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","Fragment"],"mappings":"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","file":"static/js/main.83fcb089.chunk.js","sourcesContent":["enum Algorithms {\n    BFS = \"BFS\",\n    DFS = \"DFS\",\n    DIJKSTRA = \"Dijkstra\",\n    BELLMAN_FORD = \"Bellman-Ford\",\n    KRUSKAL = \"Kruskal\"\n}\n\nexport default Algorithms","import * as React from 'react';\nimport Button from '@material-ui/core/Button';\nimport Dialog, { DialogProps } from '@material-ui/core/Dialog';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\n\ninterface AlgorithmExplanationProps {\n    contentText: JSX.Element;\n    algorithm: string;\n    open: boolean;\n    onClose: () => void;\n}\n\nexport default function AlgorithmExplanation(props: AlgorithmExplanationProps) {\n    const { algorithm, contentText, onClose, open } = props;\n    const [scroll] = React.useState<DialogProps['scroll']>('paper');\n\n    const handleClose = () => {\n        onClose();\n    };\n\n    const descriptionElementRef = React.useRef<HTMLElement>(null);\n    React.useEffect(() => {\n        if (open) {\n            const { current: descriptionElement } = descriptionElementRef;\n            if (descriptionElement !== null) {\n                descriptionElement.focus();\n            }\n        }\n    }, [open]);\n\n    return (\n        <div>\n            <Dialog\n            open={open}\n            onClose={handleClose}\n            scroll={scroll}\n            aria-labelledby=\"scroll-dialog-title\"\n            aria-describedby=\"scroll-dialog-description\"\n            >\n            <DialogTitle id=\"scroll-dialog-title\">{algorithm} - Considerações</DialogTitle>\n            <DialogContent dividers={scroll === 'paper'}>\n                <DialogContentText\n                id=\"scroll-dialog-description\"\n                ref={descriptionElementRef}\n                tabIndex={-1}\n                component=\"span\">\n                    {contentText}\n                </DialogContentText>\n            </DialogContent>\n            <DialogActions>\n                <Button onClick={handleClose}>Fechar</Button>\n            </DialogActions>\n            </Dialog>\n        </div>\n    );\n}\n","import React from 'react';\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\nimport Algorithms from '../../domain/algorithms';\nimport AddIcon from '@material-ui/icons/Add';\nimport SyncAltIcon from '@material-ui/icons/SyncAlt';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemIcon from '@material-ui/core/ListItemIcon';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport Dialog from '@material-ui/core/Dialog';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport Switch from '@material-ui/core/Switch';\nimport Button from '@material-ui/core/Button';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport TextField from '@material-ui/core/TextField';\nimport Slider from '@material-ui/core/Slider';\nimport Typography from '@material-ui/core/Typography';\nimport AlgorithmExplanation from './algorithmExplanation';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    formControl: {\n      margin: theme.spacing(1),\n      minWidth: 135,\n      marginLeft: theme.spacing(6.5)\n    },\n    formControlAddEdge: {\n      margin: theme.spacing(1),\n      minWidth: 300,\n    },\n    dialogTitle: {\n      textAlign: 'center'\n    },\n    selectEmpty: {\n      marginTop: theme.spacing(2)\n    },\n    addNodeIcon: {\n      marginTop: theme.spacing(3),\n      marginBottom: theme.spacing(1),\n      color: \"black\",\n      fontSize: 35,\n      cursor: \"pointer\",\n      marginLeft: theme.spacing(6.5)\n    },\n    addEdgeIcon: {\n      marginTop: theme.spacing(3),\n      marginBottom: theme.spacing(1),\n      marginLeft: theme.spacing(2.5),\n      color: \"black\",\n      fontSize: 30,\n      cursor: \"pointer\"\n    },\n    clearExecutionGraphBtn: {\n      marginTop: theme.spacing(5),\n      marginLeft: theme.spacing(5.5)\n    },\n    removeGraphBtn: {\n      marginTop: theme.spacing(3),\n      marginLeft: theme.spacing(6.3)\n    },\n    executeAlgorithmExecuteBtn: {\n      marginTop: theme.spacing(3),\n      marginLeft: theme.spacing(9)\n    },\n    sliderRoot: {\n      marginTop: theme.spacing(3),\n      width: 135,\n      marginLeft: theme.spacing(6.5)\n    }\n  }),\n);\n\ninterface SimpleDialogProps {\n  open: boolean;\n  nodes: number;\n  onClose: (value: IAddEdge) => void;\n}\n\ninterface IAddEdge {\n  fromNode: string;\n  toNode: string;\n  weight: string;\n}\n\nfunction SimpleDialog(props: SimpleDialogProps) {\n  const classes = useStyles();\n  const { onClose, nodes, open } = props;\n\n  const [chosenFromNode, setFromNode] = React.useState('');\n\n  const [chosenToNode, setToNode] = React.useState('');\n\n  const [chosenEdgeWeight, setEdgeWeight] = React.useState('');\n\n  const handleSelectFromNode = (event: React.ChangeEvent<{ value: unknown }>) => {\n    setFromNode(event.target.value as string);\n  };\n\n  const handleSelectToNode = (event: React.ChangeEvent<{ value: unknown }>) => {\n    setToNode(event.target.value as string);\n  };\n\n  const handleEdgeWeight = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setEdgeWeight(event.target.value as string);\n  };\n\n  const handleClose = (e: any) => {\n    if (e.target.innerText === 'ADICIONAR') {\n      onClose({fromNode: chosenFromNode, toNode: chosenToNode, weight: chosenEdgeWeight});\n    } else {\n      onClose({fromNode: '', toNode: '', weight: ''});\n    }\n    setFromNode('');\n    setToNode('');\n    setEdgeWeight('');\n  };\n\n  let nodeOptions = []\n  for (let i = 0; i < nodes; i++) {\n    nodeOptions.push(<MenuItem key={i} value={i}> {i} </MenuItem>)\n  }\n\n  return (\n    <Dialog onClose={handleClose} aria-labelledby=\"simple-dialog-title\" open={open}>\n      <DialogTitle className={classes.dialogTitle} id=\"simple-dialog-title\">Adicionar Aresta</DialogTitle>\n      <FormControl className={classes.formControlAddEdge}>\n        <InputLabel id=\"from-node-select-label\">Vértice de Saída</InputLabel>\n        <Select\n          labelId=\"from-node-select-label\"\n          id=\"from-node-select\"\n          value={chosenFromNode}\n          onChange={handleSelectFromNode}\n        >\n          {nodeOptions}\n        </Select>\n      </FormControl>\n      <FormControl className={classes.formControlAddEdge}>\n        <InputLabel id=\"to-node-select-label\">Vértice de Entrada</InputLabel>\n        <Select\n          labelId=\"to-node-select-label\"\n          id=\"to-node-select\"\n          value={chosenToNode}\n          onChange={handleSelectToNode}\n        >\n          {nodeOptions}\n        </Select>\n      </FormControl>\n      <TextField\n        className={classes.formControlAddEdge}\n        id=\"edge-weight\"\n        label=\"Peso\"\n        type=\"number\"\n        onChange={handleEdgeWeight}\n        value={chosenEdgeWeight}\n      />\n      <DialogActions>\n        <Button onClick={(e) => handleClose(e)} color=\"primary\">\n          Cancelar\n        </Button>\n        <Button onClick={(e) => handleClose(e)} color=\"primary\">\n          Adicionar\n        </Button>\n      </DialogActions>\n    </Dialog>\n  );\n}\n\nconst AlgorithmSetting = (props: any) => {\n    const classes = useStyles();\n\n    const [chosenAlgorithm, setAlgorithm] = React.useState('');\n\n    const [chosenStartingNode, setStartingNode] = React.useState('');\n\n    const [chosenTargetNode, setTargetNode] = React.useState('');\n\n    const [isDirected, setDirection] = React.useState(true);\n\n    const [chosenSpeed, setSpeed] = React.useState(2);\n\n    const [openDialog, setOpenDialog] = React.useState(false);\n\n    const [openDialogAlgorithmExp, setOpenDialogAlgorithmExp] = React.useState(false);\n\n    const handleSelectAlgorithm = (event: React.ChangeEvent<{ value: unknown }>) => {\n        setAlgorithm(event.target.value as string);\n    };\n\n    const handleSelectStartingNode = (event: React.ChangeEvent<{ value: unknown }>) => {\n        setStartingNode(event.target.value as string);\n    };\n\n    const handleSelectTargetNode = (event: React.ChangeEvent<{ value: unknown }>) => {\n        setTargetNode(event.target.value as string);\n    };\n\n    const handleExecutionSpeed = (event: React.ChangeEvent<{}>, newValue: number | number[]) => {\n      setSpeed(Number(newValue));\n    }\n\n    const handleValueText = (speed: number) => {\n      return `${speed}s`;\n    }\n\n    const handleEdgeDirection = (event: React.ChangeEvent<HTMLInputElement>) => {\n      setDirection(event.target.checked);\n      props.changeGraphDirection(event.target.checked);\n    };\n\n    const handleClickOpenDialog = () => {\n      setOpenDialog(true);\n    };\n\n    const handleCloseDialog = (edge: IAddEdge) => {\n      setOpenDialog(false);\n      if (edge.fromNode !== '' && edge.toNode !== '') {\n        props.addEdge(+edge.fromNode, +edge.toNode, edge.weight );\n      }\n    };\n\n    const handleOpenDialogAlgorithmExp = () => {\n      setOpenDialogAlgorithmExp(true);\n    }\n\n    const handleCloseDialogAlgorithmExp = () => {\n      setOpenDialogAlgorithmExp(false);\n      const executionOption = { algorithm: chosenAlgorithm, startingNode: chosenStartingNode, targetNode: chosenTargetNode, speed: chosenSpeed };\n      props.executeVisualization(executionOption);\n    }\n\n    const handleExecuteAlgorithm = () => {\n      handleOpenDialogAlgorithmExp();\n    }\n\n    const handleAlgorithmExpContentText = () => {\n      if (chosenAlgorithm === Algorithms.BFS.toString()) {\n        return (\n          <div style={{\n            color: 'black'\n          }}>\n            <h4>Proposta</h4>\n            <p>O algoritmo BFS visita todos os vértices de um grafo e explora apenas arestas que ainda não foram visitadas.</p>\n            <p>Pode ser executado para grafos dirigidos e não-dirigidos. </p>\n            <p>Geralmente é utilizado para descobrir todos vértices que podem ser alcançados a partir de um vértice inicial, sendo essa a execução utilizada nessa ferramenta de visualização.</p>\n            <p>BFS não resolve um problema específico, é um algoritmo intermediário que pode ser utilizado para resolver diversos problemas na computação, como por exemplo, motores de recomendações até K níveis de distância.</p>\n            <h4>Execução</h4>\n            <p>Todos os vértices adjacentes de um vértice <i>v</i> são descobertos antes de continuar explorando o grafo, sendo oposto do DFS.</p>\n            <p>Há possibilidade de adaptá-lo para determinar o caminho mais curto entre dois vértices de um grafo sem peso nas arestas.</p>\n            <h4>Complexidade de Tempo</h4>\n            <p>A complexidade de tempo de execução por Grande-O é O(V + E), sendo V o número de vértices e E o número de arestas.</p>\n            <h4>Considerações da Ferramenta</h4>\n            <p>Caso possua, o peso das arestas é ignorado na execução.</p>\n          </div>\n        )\n      } else if (chosenAlgorithm === Algorithms.DFS.toString()) {\n          return (\n            <div style={{\n              color: 'black'\n            }}>\n              <h4>Proposta</h4>\n              <p>O algoritmo DFS visita todos os vértices de um grafo e explora apenas arestas que ainda não foram visitadas. </p>\n              <p>Pode ser executado para grafos dirigidos e não-dirigidos. </p>\n              <p>Geralmente é utilizado para descobrir todos vértices que podem ser alcançados a partir de um vértice inicial, sendo essa a execução utilizada nessa ferramenta de visualização. </p>\n              <p>Frequentemente é adaptado para gerar uma ordem topológica dos vértices do grafo, sendo utilizada para situações onde há uma ordem de execução de tarefas a ser respeitada. </p>\n              <p>Não é possível descobrir o caminho mais curto entre dois vértices de um grafo sem ou com peso nas arestas. </p>\n              <h4>Execução</h4>\n              <p>Sempre que possível, DFS aprofunda até o último nível de um caminho através das arestas. Quando não há outra aresta para percorrer, o algoritmo realiza backtracking para visitar todas arestas dos vértices anteriores.  </p>\n              <h4>Complexidade de Tempo</h4>\n              <p>A complexidade de tempo de execução por Grande-O é O(V + E), sendo V o número de vértices e E o número de arestas.</p>\n              <h4>Considerações da Ferramenta</h4>\n              <p>Caso possua, o peso das arestas é ignorado na execução.</p>\n            </div>\n          )\n      } else if (chosenAlgorithm === Algorithms.DIJKSTRA.toString()) {\n          return (\n            <div style={{\n              color: 'black'\n            }}>\n              <h4>Proposta</h4>\n              <p>O algoritmo de Dijkstra visa resolver o problema de caminho mais curto em um grafo dirigido ou não-dirigido com pesos não-negativos nas arestas. O caminho mais curto é calculado pela soma dos pesos das arestas. </p>\n              <p>É semelhante ao algoritmo de Bellman-Ford e melhor complexidade de tempo, no entanto, Dijkstra falha em grafos com pesos negativos nas arestas. </p>\n              <h4>Execução</h4>\n              <p>Quando é executado a partir de um vértice inicial <i>v</i>, é calculado o caminho mais curto entre <i>v</i> e todos os outros vértices que podem ser alcançados. </p>\n              <p>Após término do algoritmo, geralmente busca-se o caminho mais curto entre dois vértices específicos, sendo essa a proposta de implementação nessa ferramenta. </p>\n              <h4>Complexidade de Tempo</h4>\n              <p>A complexidade de tempo de execução por Grande-O é O(E * log(V)), sendo E o número de arestas e V o número de vértices.</p>\n              <h4>Considerações da Ferramenta</h4>\n              <p>Arestas sem peso terão valor 1 inferido nos cálculos.</p>\n              <p>Para visualizar o caminho mais curto entre dois vértices, escolha o vértice inicial e final no menu à esquerda.</p>\n            </div>\n          )\n      } else if (chosenAlgorithm === Algorithms.BELLMAN_FORD.toString()) {\n          return (\n            <div style={{\n              color: 'black'\n            }}>\n              <h4>Proposta</h4>\n              <p>O algoritmo de Bellman-Ford visa resolver o problema de caminho mais curto em um grafo dirigido ou não-dirigido e permitindo pesos negativos nas arestas. O caminho mais curto é calculado pela soma dos pesos das arestas. </p>\n              <p>Por possuir tempo de execução maior do que Dijkstra, é recomendado utilizar apenas quando há possibilidade de pesos negativos nas arestas, pois o algoritmo de Dijkstra falha nesse quesito.</p>\n              <h4>Execução</h4>\n              <p>Quando é executado a partir de um vértice inicial <i>v</i>, é calculado o caminho mais curto entre <i>v</i> e todos os outros vértices que podem ser alcançados. </p>\n              <p>Após término do algoritmo, geralmente busca-se o caminho mais curto entre dois vértices específicos, sendo essa a proposta de implementação nessa ferramenta. </p>\n              <h4>Complexidade de Tempo</h4>\n              <p>A complexidade de tempo de execução por Grande-O é O(V * E), sendo V o número de vértices e E o número de arestas.</p>\n              <h4>Considerações da Ferramenta</h4>\n              <p>Arestas sem peso terão valor 1 inferido nos cálculos.</p>\n              <p>Para visualizar o caminho mais curto entre dois vértices, escolha o vértice inicial e final no menu à esquerda.</p>\n            </div>\n          )\n      } else if (chosenAlgorithm === Algorithms.KRUSKAL.toString()) {\n          return (\n            <div style={{\n              color: 'black'\n            }}>\n              <h4>Proposta</h4>\n              <p>O algoritmo de Kruskal encontra a árvore geradora mínima com menor peso em um grafo não-dirigido. </p>\n              <p>Uma árvore geradora é um sub-grafo com todos as arestas que conectam todos os vértices do grafo original. </p>\n              <p>Cada vértice precisa ter ao menos uma areasta.</p>\n              <h4>Execução</h4>\n              <p>Nesse caso, busca-se o conjunto de arestas com menor peso e que conecte todos os vértices do grafo.</p>\n              <p>O peso de uma árvore geradora mínima é dado pela soma do peso de todas as arestas.</p>\n              <h4>Complexidade de Tempo</h4>\n              <p>A complexidade de tempo de execução por Grande-O é O(E log E), sendo E o número de arestas.</p>\n              <h4>Considerações da Ferramenta</h4>\n              <p>A ferramenta permite execução em grafos dirigidos para fins didáticos. </p>\n              <p>Arestas sem peso terão valor 1 inferido nos cálculos.</p>\n            </div>\n          )\n      } else {\n          return (\n            <div></div>\n          )\n      }\n    }\n\n    const handleClearGraph = () => {\n      setStartingNode('');\n      setTargetNode('');\n      props.clearGraph();\n    }\n\n    const handleClearExecution = () => {\n      props.clearExecution();\n    }\n\n    const mustHasStartNode = () => {\n      return [Algorithms.KRUSKAL.toString()].indexOf(chosenAlgorithm) === -1;\n    }\n\n    const mustHasTargetNode = () => {\n      return [Algorithms.BFS.toString(), Algorithms.DFS.toString(), Algorithms.KRUSKAL.toString()].indexOf(chosenAlgorithm) === -1;\n    }\n\n    const marks = [\n    {\n      value: 1,\n      label: '1s',\n    },\n    {\n      value: 3,\n      label: '3s',\n    },\n    {\n      value: 5,\n      label: '5s',\n    }\n  ];\n\n    const algorithms = [Algorithms.BFS, Algorithms.DFS, Algorithms.DIJKSTRA, Algorithms.BELLMAN_FORD, Algorithms.KRUSKAL]\n    let algorithmOptions = []\n    for (let i = 0; i < algorithms.length; i++) {\n        algorithmOptions.push(<MenuItem key={algorithms[i]} value={algorithms[i]}> {algorithms[i]} </MenuItem>)\n    }\n\n    let nodeOptions = []\n    for (let i = 0; i < props.nodes; i++) {\n      nodeOptions.push(<MenuItem key={i} value={i}> {i} </MenuItem>)\n    }\n    return (\n        <div>\n          <FormControl className={classes.formControl}>\n            <FormControlLabel\n              control={\n                <Switch\n                  checked={isDirected}\n                  onChange={handleEdgeDirection}\n                  name=\"edgeDirection\"\n                  color=\"primary\"\n                />\n              }\n              label=\"Grafo Dirigido\"\n              disabled={props.nodes > 0}\n            />\n          </FormControl>\n          <FormControl className={classes.formControl}>\n            <InputLabel id=\"algorithm-select-label\">Algoritmo</InputLabel>\n            <Select\n            labelId=\"algorithm-select-label\"\n            id=\"algorithm-select\"\n            value={chosenAlgorithm}\n            onChange={handleSelectAlgorithm}\n            >\n                {algorithmOptions}\n            </Select>\n          </FormControl>\n            <ListItem >\n              <ListItemIcon>\n                <Tooltip title=\"Adicionar Vértice\">\n                  <AddIcon className={classes.addNodeIcon} aria-label=\"Adicionar Vértice\" onClick={() => { props.addNode() }}/>\n                </Tooltip>\n              </ListItemIcon>\n              <ListItemIcon>\n                <Tooltip title=\"Adicionar Aresta\">\n                  <SyncAltIcon className={classes.addEdgeIcon} aria-label=\"Adicionar Aresta\" onClick={() => handleClickOpenDialog()} />\n                </Tooltip>\n              </ListItemIcon>\n            </ListItem>\n          <FormControl className={classes.formControl}>\n            <InputLabel id=\"starting-node-select-label\">Vértice Inicial</InputLabel>\n            <Select\n            labelId=\"starting-node-select-label\"\n            id=\"starting-node-select\"\n            value={chosenStartingNode}\n            onChange={handleSelectStartingNode}\n            disabled={!mustHasStartNode()}\n            >\n                {nodeOptions}\n            </Select>\n          </FormControl>\n          <FormControl className={classes.formControl}>\n            <InputLabel id=\"target-node-select-label\">Vértice Destino</InputLabel>\n            <Select\n            labelId=\"target-node-select-label\"\n            id=\"target-node-select\"\n            value={chosenTargetNode}\n            onChange={handleSelectTargetNode}\n            disabled={!mustHasTargetNode()}\n            >\n                {nodeOptions}\n            </Select>\n          </FormControl>\n          <div className={classes.sliderRoot}>\n            <Typography id=\"discrete-slider-small-steps\" gutterBottom>\n              Velocidade\n            </Typography>\n            <Slider\n              defaultValue={2}\n              getAriaValueText={handleValueText}\n              aria-labelledby=\"discrete-slider-small-steps\"\n              step={1}\n              marks={marks}\n              min={1}\n              max={5}\n              onChange={handleExecutionSpeed}\n              value={chosenSpeed}\n              valueLabelDisplay=\"auto\"\n            />\n          </div>\n          <div>\n            <Button className={classes.executeAlgorithmExecuteBtn} variant=\"contained\" color=\"primary\" onClick={() => handleExecuteAlgorithm()}>\n              Executar\n            </Button>\n            <Button className={classes.clearExecutionGraphBtn} variant=\"contained\" onClick={() => handleClearExecution()}>\n              Limpar Execução\n            </Button>\n            <Button className={classes.removeGraphBtn} variant=\"contained\" onClick={() => handleClearGraph()}>\n              Remover Grafo\n            </Button>\n          </div>\n          <SimpleDialog nodes={props.nodes} open={openDialog} onClose={handleCloseDialog} />\n          <AlgorithmExplanation algorithm={chosenAlgorithm} contentText={handleAlgorithmExpContentText()} open={openDialogAlgorithmExp} onClose={handleCloseDialogAlgorithmExp} />\n        </div>\n    );\n}\n\nexport default AlgorithmSetting;\n","enum Colors {\n    GREY = '#CCCCCC',\n    RED   = '#ff0000',\n    GREEN = '#009933',\n    PURPLE = '#6600cc'\n}\n\nexport default Colors","import React from 'react';\nimport clsx from 'clsx';\nimport { makeStyles, useTheme, Theme, createStyles } from '@material-ui/core/styles';\nimport Drawer from '@material-ui/core/Drawer';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport Divider from '@material-ui/core/Divider';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport ChevronLeftIcon from '@material-ui/icons/ChevronLeft';\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\nimport AlgorithmSetting from './settings/algorithmSetting';\n\nconst drawerWidth = 240;\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: 'flex',\n    },\n    appBar: {\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n    },\n    appBarShift: {\n      width: `calc(100% - ${drawerWidth}px)`,\n      marginLeft: drawerWidth,\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n    },\n    menuButton: {\n      marginRight: theme.spacing(2),\n    },\n    hide: {\n      display: 'none',\n    },\n    drawer: {\n      width: drawerWidth,\n      flexShrink: 0,\n    },\n    drawerPaper: {\n      width: drawerWidth,\n    },\n    drawerHeader: {\n      display: 'flex',\n      alignItems: 'center',\n      padding: theme.spacing(0, 1),\n      // necessary for content to be below app bar\n      ...theme.mixins.toolbar,\n      justifyContent: 'flex-end',\n    },\n    content: {\n      flexGrow: 1,\n      padding: theme.spacing(3),\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n      marginLeft: -drawerWidth,\n    },\n    contentShift: {\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n      marginLeft: 0,\n    }\n  }),\n);\n\nconst SideBar = (props: any) => {\n  const classes = useStyles();\n  const theme = useTheme();\n\n  const [open, setOpen] = React.useState(true);\n\n  const handleDrawerOpen = () => {\n    setOpen(true);\n  };\n\n  const handleDrawerClose = () => {\n    setOpen(false);\n  };\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <AppBar\n        position=\"fixed\"\n        className={clsx(classes.appBar, {\n          [classes.appBarShift]: open,\n        })}\n      >\n        <Toolbar>\n          <IconButton\n            color=\"inherit\"\n            aria-label=\"open drawer\"\n            onClick={handleDrawerOpen}\n            edge=\"start\"\n            className={clsx(classes.menuButton, open && classes.hide)}\n          >\n            <MenuIcon />\n          </IconButton>\n          <Typography variant=\"h6\" noWrap>\n            VisiGraph - Visualizador de Algoritmos em Grafos\n          </Typography>\n        </Toolbar>\n      </AppBar>\n      <Drawer\n        className={classes.drawer}\n        variant=\"persistent\"\n        anchor=\"left\"\n        open={open}\n        classes={{\n          paper: classes.drawerPaper,\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handleDrawerClose}>\n            {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}\n          </IconButton>\n        </div>\n        <Divider />\n        <div>\n          <AlgorithmSetting \n            executeVisualization={props.executeVisualization}\n            clearGraph={props.clearGraph}\n            clearExecution={props.clearExecution}\n            nodes={props.nodes} \n            addEdge={props.addEdge} \n            addNode={props.addNode}\n            changeGraphDirection={props.changeGraphDirection}\n          />\n        </div>\n      </Drawer>\n    </div>\n  );\n}\n\nexport default SideBar;\n","class PriorityQueue {\n    collection : Element[];\n    \n    constructor() {\n        this.collection = [];\n    }\n\n    enqueue(element: Element) {\n        if (this.isEmpty()){ \n            this.collection.push(element);\n        } else {\n            let added = false;\n            for (let i = 1; i <= this.collection.length; i++){\n                if (element.weightToNode < this.collection[i-1].weightToNode){ \n                this.collection.splice(i-1, 0, element);\n                added = true;\n                break;\n                }\n            }\n            if (!added){\n                this.collection.push(element);\n            }\n        }\n    }\n\n    dequeue() {\n        return this.collection.shift();\n    }\n\n    isEmpty() {\n        return this.collection.length === 0;\n    }\n}\n\ninterface Element {\n    targetNode: number;\n    weightToNode: number;\n}\n\nexport default PriorityQueue","import React from 'react';\n\nimport Alert from '@material-ui/lab/Alert';\n\nclass Message extends React.Component<any, any> {\n\n    render() {\n        return (\n            <div style={{\n                width: '100%'\n            }}>\n                { this.props.show && <Alert severity=\"info\">{this.props.message}</Alert> }\n            </div>\n        );\n    }\n}\n\nexport default Message;","import React from 'react';\n\nimport SideBar from './sidebar';\nimport AlgorithmChoose from '../domain/algorithmChoose';\nimport Algorithms from '../domain/algorithms';\nimport Colors from '../domain/colors';\n\nimport greuler from \"greuler\";\nimport PriorityQueue from '../data-structure/priorityQueue';\nimport Message from './message';\n\ninterface UnweightedGraph {\n    target: number;\n    edgeIdx: number;\n}\n\ninterface WeightedGraph {\n    target: number;\n    edgeIdx: number;\n    weight: number;\n}\n\ninterface Edge {\n    source: number;\n    target: number;\n    weight: number;\n    edgeId: number;\n}\n\ninterface EdgeIdx {\n    node: number;\n    idx: number;\n}\n\ninterface UnionFindParentRank {\n    parent: number;\n    rank: number;\n}\n\nclass Home extends React.Component<any, any> {\n\n    constructor(props: any) {\n        super(props);\n\n        this.addNode = this.addNode.bind(this);\n        this.addEdge = this.addEdge.bind(this);\n        this.handleGraphDirection = this.handleGraphDirection.bind(this);\n        this.clearGraph = this.clearGraph.bind(this);\n        this.clearExecution = this.clearExecution.bind(this);\n        this.executeGraphVisualization = this.executeGraphVisualization.bind(this);\n        this.updateFinishAlgorithmState = this.updateFinishAlgorithmState.bind(this);\n\n        this.state = {\n            graphStruct: null,\n            isDirected: true,\n            speed: null,\n            executed: true,\n            start: false,\n            finish: false\n        };\n    }\n\n    componentDidMount = async () => {\n        await this.getElementByIdAsync('app');\n        this.startGraph();\n    }\n\n    startGraph() {\n        this.setState({\n            graphStruct: greuler({\n                target: \"#app\"\n            }).update()\n        });\n    }\n\n    addNode() {\n        let oldGraphState = this.state.graphStruct;\n        const nextNodeId = oldGraphState.graph.nodes.length;\n\n        oldGraphState.graph.addNode({ id: nextNodeId })\n\n        this.setState({\n            graphStruct: oldGraphState.update()\n        });\n    }\n\n    addEdge(fromNode: number, toNode: number, weight: string) {\n        let oldGraphState = this.state.graphStruct;\n\n        const u = oldGraphState.graph.nodes[fromNode];\n        const v = oldGraphState.graph.nodes[toNode];\n\n        if (!u || !v) return;\n\n        let edge: any;\n        if (weight !== '') {\n            edge = { source: u.id, target: v.id, directed: this.state.isDirected, displayWeight: weight };\n        } else {\n            edge = { source: u.id, target: v.id, directed: this.state.isDirected };\n        }\n        \n        oldGraphState.graph.addEdge(edge);\n\n        this.setState({\n            graphStruct: oldGraphState.update()\n        });\n    }\n\n    handleGraphDirection(isDirected: boolean) {\n        this.setState({\n            isDirected: isDirected\n        });\n    }\n\n    executeGraphVisualization(executionOption: AlgorithmChoose) {\n        this.setState({\n            speed: executionOption.speed,\n            executed: true,\n            start: true,\n            finish: false\n        }, () => {\n            setTimeout( () => {\n                this.setState({\n                    start: false\n                });\n            }, 2000)\n        });\n\n        const instance = this.state.graphStruct;\n        if (executionOption.algorithm === Algorithms.DFS) {\n            let adjacencyList = this.makeUnweightedGraph();\n            this.dfs(instance, adjacencyList, executionOption.startingNode, []).then(() => {\n                this.updateFinishAlgorithmState();\n            });\n        } else if (executionOption.algorithm === Algorithms.BFS) {\n            let adjacencyList = this.makeUnweightedGraph();\n            this.bfs(instance, adjacencyList, executionOption.startingNode).then(() => {\n                this.updateFinishAlgorithmState();\n            });\n        } else if (executionOption.algorithm === Algorithms.DIJKSTRA) {\n            let adjacencyList = this.makeWeightedGraph();\n            this.dijkstra(instance, adjacencyList, executionOption.startingNode, executionOption.targetNode).then(() => {\n                this.updateFinishAlgorithmState();\n            });\n        } else if (executionOption.algorithm === Algorithms.BELLMAN_FORD) {\n            let edgeList = this.makeEdgeListGraph();\n            this.bellmanFord(instance, edgeList, executionOption.startingNode, executionOption.targetNode).then(() => {\n                this.updateFinishAlgorithmState();\n            });\n        } else if (executionOption.algorithm === Algorithms.KRUSKAL) {\n            let edgeList = this.makeEdgeListGraph();\n            this.kruskal(instance, edgeList).then(() => {\n                this.updateFinishAlgorithmState();\n            });\n        }\n    }\n\n    updateFinishAlgorithmState() {\n        this.setState({\n            finish: true\n        }, () => {\n            setTimeout( () => {\n                this.setState({\n                    finish: false\n                });\n            }, 4000)\n        });\n    }\n\n    async dfs(instance: any, adjacencyList: Array<Array<UnweightedGraph>>, v: number, visited: boolean[]) {\n        try {\n            await this.delay(this.state.speed);\n            visited[v] = true;\n            for (let i = 0; adjacencyList[v] && i < adjacencyList[v].length; i++) {\n                if (visited[adjacencyList[v][i].target]) {\n                    continue;\n                }\n                const edge = instance.graph.edges[adjacencyList[v][i].edgeIdx];\n                instance.selector.getEdge({id: edge.id}).attr('stroke', Colors.RED);\n                await this.dfs(instance, adjacencyList, adjacencyList[v][i].target, visited);\n            }\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n\n    async bfs(instance: any, adjacencyList: Array<Array<UnweightedGraph>>, v: number) {\n        try {\n            let visited: boolean[] = []\n\n            let queue: number[] = []\n\n            visited[v] = true;\n            queue.push(v);\n\n            await this.delay(this.state.speed);\n\n            while (queue.length) {\n                let currentNode : number = queue.shift() as number;\n                for (let i = 0; adjacencyList[currentNode] && i < adjacencyList[currentNode].length; i++) {\n                    if (visited[adjacencyList[currentNode][i].target]){\n                        continue;\n                    }\n                    const edge = instance.graph.edges[adjacencyList[currentNode][i].edgeIdx];\n                    instance.selector.getEdge({id: edge.id}).attr('stroke', Colors.RED);\n\n                    visited[adjacencyList[currentNode][i].target] = true;\n                    queue.push(adjacencyList[currentNode][i].target);\n\n                    await this.delay(this.state.speed);\n                }\n            }\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n\n    async dijkstra(instance: any, adjacencyList: Array<Array<WeightedGraph>>, startNode: number, targetNode: number) {\n        try {\n            let times: number[] = [];\n            times[startNode] = 0;\n            let nodes = instance.graph.nodes;\n            nodes.forEach((node: any) => {\n                if (node.id !== startNode) {\n                    times[Number(node.id)] = Infinity;\n                }\n            });\n\n            let backtrace: EdgeIdx[] = [];\n\n            let pq = new PriorityQueue();\n            pq.enqueue({targetNode: startNode, weightToNode: 0});\n            \n            while (!pq.isEmpty()) {\n                let shortestStep = pq.dequeue();\n                let currentNode = shortestStep?.targetNode;\n\n                if (adjacencyList[currentNode!]) {\n                    for (let i = 0; i < adjacencyList[currentNode!].length; i++) {\n                        let neighbor = adjacencyList[currentNode!][i];\n                        const edge = instance.graph.edges[neighbor.edgeIdx];\n                        instance.selector.getEdge({id: edge.id}).attr('stroke', Colors.GREEN);\n                        await this.delay(this.state.speed);\n                        let time = Number(times[currentNode!]) + Number(neighbor.weight);\n\n                        if (time < times[neighbor.target]) {\n                            times[neighbor.target] = time;\n                            backtrace[neighbor.target] = {node: currentNode!, idx: neighbor.edgeIdx};\n                            pq.enqueue({targetNode: neighbor.target, weightToNode: time});\n                        }\n                    }\n                }\n            }\n\n            let pathIdx = [];\n            let lastStep = targetNode;\n\n            while(lastStep !== startNode) {\n                pathIdx.unshift(backtrace[lastStep].idx);\n                lastStep = backtrace[lastStep].node;\n            }\n\n            pathIdx.forEach(edgeIdx => {\n                const edge = instance.graph.edges[edgeIdx];\n                instance.selector.getEdge({id: edge.id}).attr('stroke', Colors.RED);\n            });\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n\n    async bellmanFord(instance: any, edgeList: Array<Edge>, startNode: number, targetNode: number) {\n        try {\n            let dist: number[] = [];\n            dist[startNode] = 0;\n            let nodes = instance.graph.nodes;\n            nodes.forEach((node: any) => {\n                if (node.id !== startNode) {\n                    dist[Number(node.id)] = Infinity;\n                }\n            });\n\n            let backtrace: EdgeIdx[] = [];\n\n            let nodesLength = instance.graph.nodes.length;\n            for (let i = 1; i <= nodesLength; i++) {\n                for (let j = 0; j < edgeList.length; j++) {\n                    let source = edgeList[j].source;\n                    let target = edgeList[j].target;\n                    let weight = Number(edgeList[j].weight);\n\n                    if (dist[source] !== Infinity && dist[source] + weight < dist[target]) {\n                        dist[target] = Number(dist[source]) + Number(weight);\n                        backtrace[target] = {node: source, idx: edgeList[j].edgeId}\n                    }\n\n                    let color = i % 2 === 0 ? Colors.GREEN : Colors.PURPLE;\n                    instance.selector.getEdge({id: edgeList[j].edgeId}).attr('stroke', color);\n                    await this.delay(Math.floor(this.state.speed/2));\n                }\n            }\n\n            for (let i = 0; i < edgeList.length; i++) {\n                let source = edgeList[i].source;\n                let target = edgeList[i].target;\n                let weight = Number(edgeList[i].weight);\n                if (dist[source] !== Infinity && dist[source] + weight < dist[target]) {\n                    console.log(\"negative weight cycle\");\n                    return;\n                }\n            }\n\n            let pathIdx = [];\n            let lastStep = targetNode;\n\n            while(lastStep !== startNode) {\n                pathIdx.unshift(backtrace[lastStep].idx);\n                lastStep = backtrace[lastStep].node;\n            }\n\n            pathIdx.forEach(edgeIdx => {\n                instance.selector.getEdge({id: edgeIdx}).attr('stroke', Colors.RED);\n            });\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n\n    async kruskal(instance: any, edgeList: Array<Edge>) {\n        try {\n            let sortedEdges: Array<Edge> = edgeList.sort((a, b) => Number(a.weight) - Number(b.weight));\n\n            let mst: number[] = [];\n            let components: UnionFindParentRank[] = [];\n\n            let nodes = instance.graph.nodes;\n            for (let i = 0; i < nodes.length; i++) {\n                components.push({parent: i, rank: 0});\n            }\n\n            let edgeCount = 0;\n            let idx = 0;\n\n            while (edgeCount < nodes.length - 1) {\n                let sourceRoot = await this.find(components, sortedEdges[idx].source);\n                let targetRoot = await this.find(components, sortedEdges[idx].target);\n\n                instance.selector.getEdge({id: sortedEdges[idx].edgeId}).attr('stroke', Colors.GREEN);\n                await this.delay(this.state.speed);\n\n                if (sourceRoot !== targetRoot) {\n                    mst.push(sortedEdges[idx].edgeId);\n                    edgeCount = edgeCount + 1;\n                    await this.union(components, sourceRoot, targetRoot);\n                }\n\n                idx = idx + 1;\n            }\n\n            edgeList.forEach(edge => {\n                instance.selector.getEdge({id: edge.edgeId}).attr('stroke', Colors.GREY);\n            });\n            \n            mst.forEach(edgeIdx => {\n                instance.selector.getEdge({id: edgeIdx}).attr('stroke', Colors.RED);\n            });\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n    }\n\n    async find(components: UnionFindParentRank[], element: number): Promise<number> {\n        if (components[element].parent === element) {\n            return element\n        }\n        return await this.find(components, components[element].parent)\n    }\n\n    async union(components: UnionFindParentRank[], elementX: number, elementY: number) {\n        let rootX = await this.find(components, elementX);\n        let rootY = await this.find(components, elementY);\n\n        if (components[rootX].rank < components[rootY].rank) {\n            components[rootX].parent = rootY;\n        } else if (components[rootX].rank > components[rootY].rank) {\n            components[rootY].parent = rootX;\n        } else {\n            components[rootY].parent = rootX;\n            components[rootX].rank = components[rootX].rank + 1;\n        }\n    }\n\n    clearGraph() {\n        let oldGraphState = this.state.graphStruct;\n        \n        oldGraphState.graph.removeNodesByFn((n: { id: number; }) => n.id >= 0);\n\n        this.setState({\n            graphStruct: oldGraphState.update(),\n            executed: false\n        });\n    }\n\n    clearExecution() {\n        const instance = this.state.graphStruct;\n        for (let i = 0; i < instance.graph.edges.length; i++) {\n            const edgeIdx = instance.graph.edges[i].id;\n            instance.selector.getEdge({id: edgeIdx}).attr('stroke', Colors.GREY);\n        }\n\n        this.setState({\n            executed: false\n        });\n    }\n\n    getElementByIdAsync = (id: string) => new Promise(resolve => {\n        const getElement = () => {\n            const element = document.getElementById(id);\n            if(element) {\n                resolve(element);\n            } else {\n                requestAnimationFrame(getElement);\n            }\n        };\n        getElement();\n    });\n\n    delay(n: number){\n        return new Promise(function(resolve){\n            setTimeout(resolve,n*1000);\n        });\n    }\n\n    makeUnweightedGraph() {\n        let adjacencyList: Array<Array<UnweightedGraph>> = [];\n        const instance = this.state.graphStruct;\n        for (let i = 0; i < instance.graph.edges.length; i++) {\n            const source = instance.graph.edges[i].source.id;\n            const target = instance.graph.edges[i].target.id;\n            if (this.state.executed) {\n                const edgeIdx = instance.graph.edges[i].id;\n                instance.selector.getEdge({id: edgeIdx}).attr('stroke', Colors.GREY);\n            }\n\n            if (!adjacencyList[source]) {\n                adjacencyList[source] = [];\n            }\n            adjacencyList[source].push({target: target, edgeIdx: i});\n            \n            if (!this.state.isDirected) {\n                if (!adjacencyList[target]) {\n                    adjacencyList[target] = [];\n                }\n                adjacencyList[target].push({target: source, edgeIdx: i});\n            }\n        }\n        return adjacencyList;\n    }\n\n    makeWeightedGraph() {\n        let adjacencyList: Array<Array<WeightedGraph>> = [];\n        const instance = this.state.graphStruct;\n        for (let i = 0; i < instance.graph.edges.length; i++) {\n            const source = instance.graph.edges[i].source.id;\n            const target = instance.graph.edges[i].target.id;\n            const weight = instance.graph.edges[i].displayWeight ? instance.graph.edges[i].displayWeight : 1;\n            if (this.state.executed) {\n                const edgeIdx = instance.graph.edges[i].id;\n                instance.selector.getEdge({id: edgeIdx}).attr('stroke', Colors.GREY);\n            }\n\n            if (!adjacencyList[source]) {\n                adjacencyList[source] = [];\n            }\n            adjacencyList[source].push({target: target, edgeIdx: i, weight: weight});\n            \n            if (!this.state.isDirected) {\n                if (!adjacencyList[target]) {\n                    adjacencyList[target] = [];\n                }\n                adjacencyList[target].push({target: source, edgeIdx: i, weight: weight});\n            }\n        }\n        return adjacencyList;\n    }\n\n    makeEdgeListGraph() {\n        let edgeList: Array<Edge> = [];\n        const instance = this.state.graphStruct;\n        for (let i = 0; i < instance.graph.edges.length; i++) {\n            const source = instance.graph.edges[i].source.id;\n            const target = instance.graph.edges[i].target.id;\n            const weight = instance.graph.edges[i].displayWeight ? instance.graph.edges[i].displayWeight : 1;\n            const edgeId = instance.graph.edges[i].id;\n            if (this.state.executed) {\n                instance.selector.getEdge({id: edgeId}).attr('stroke', Colors.GREY);\n            }\n            edgeList.push({source: source, target: target, weight: weight, edgeId: edgeId});\n        }\n        return edgeList;\n    }\n\n    render() {\n        return (\n            <div>\n                <div>\n                    <SideBar \n                        executeVisualization={this.executeGraphVisualization}\n                        clearGraph={this.clearGraph}\n                        clearExecution={this.clearExecution}\n                        nodes={this.state.graphStruct !== null ? this.state.graphStruct.graph.nodes.length : 0} \n                        addEdge={this.addEdge} \n                        addNode={this.addNode}\n                        changeGraphDirection={this.handleGraphDirection}\n                    />\n                </div>\n                <div style={{\n                            marginLeft: '70%',\n                            marginTop: '5%',\n                            width: '25%'\n                    }}>\n                    <Message show={this.state.start || this.state.finish} message={this.state.start ? 'Iniciando Execução' : 'Execução Finalizada'} />\n                </div> \n                <div style={{\n                    position: 'absolute', left: '50%', top: '50%',\n                    transform: 'translate(-50%, -50%)',\n                    height: '100vh',\n                    width: '100%'\n                }}>\n                    <div id=\"app\" style={{\n                        height: '100vh', \n                        width: '100%'\n                    }}>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Home\n","import React from 'react';\n\nimport Home from './components/home';\n\nfunction App() {\n\treturn (\n\t\t<Home />\n\t);\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './app';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './index.css';\nimport 'fontsource-roboto';\n\nReactDOM.render(\n  <React.Fragment>\n    <App />\n  </React.Fragment>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}